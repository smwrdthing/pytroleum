import numpy as np


def feed_cdf_rosin_rammler(d: np.ndarray, k: float, n: float) -> np.ndarray:
    """
    Кумулятивное распределение частиц y по Розин-Раммлеру.

    Уравнение (20) из статьи Pana-Suppamassadu et al. (2007):
    y(d) = 1 - exp(-(d/k)^n)

    Параметры:
    ----------
    d : np.ndarray
        Размеры частиц, м
    k : float
        Характерный размер, м
    n : float
        Параметр формы распределения

    Возвращает:
    -----------
    np.ndarray
        Кумулятивное распределение y(d)
    """
    d = np.asarray(d, dtype=float)
    return 1.0 - np.exp(-(d / k)**n)


def feed_cdf_rosin_rammler_derivative(d: np.ndarray, k: float, n: float) -> np.ndarray:
    """
    Производная кумулятивного распределения частиц по Розин-Раммлеру.

    Параметры:
    ----------
    d : np.ndarray
        Размеры частиц, м
    k : float
        Характерный размер, м
    n : float
        Параметр формы распределения

    Возвращает:
    -----------
    np.ndarray
        Производная dy/dd
    """

    # NOTE производная кумулятивной функции распределения - плотность вероятности
    # NOTE (probability density)
    # NOTE
    # NOTE Здесь и выше, думаю, допустимо убрать из названия функции Розина-Раммлера
    # NOTE и вынести это в докстринги, потому что сейчас функция одна, а когда (или если)
    # NOTE мы будем добавлять другие функции распределения - целесообразнее будет всё
    # NOTE вынести в отдельный пакет вне solid_cyclone или liquid_cyclone

    # NOTE конверсия в массив избыточна, если в сигнатуре мы уже просим массив,
    # NOTE то же в функции выше
    d = np.asarray(d, dtype=float)
    ratio = d / k
    dy_dd = (n / k) * (ratio)**(n - 1) * np.exp(-(ratio)**n)
    return dy_dd

# NOTE для текущей проработки дробление по модулям выглядит слишком мелким, можно
# NOTE объединить этот модуль и efficiency в один, который будет отвечать за расчёты,
# NOTE связанные с сепарацией
